"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _element = require("@wordpress/element");
var _hooks = require("preact/hooks");
var _deepsignal = require("deepsignal");
var _portals = require("./portals");
var _utils = require("./utils");
var _hooks2 = require("./hooks");
var _slots = require("./slots");
/**
 * External dependencies
 */

/**
 * Internal dependencies
 */

const isObject = item => item && typeof item === 'object' && !Array.isArray(item);
const mergeDeepSignals = (target, source, overwrite) => {
  for (const k in source) {
    if (isObject((0, _deepsignal.peek)(target, k)) && isObject((0, _deepsignal.peek)(source, k))) {
      mergeDeepSignals(target[`$${k}`].peek(), source[`$${k}`].peek(), overwrite);
    } else if (overwrite || typeof (0, _deepsignal.peek)(target, k) === 'undefined') {
      target[`$${k}`] = source[`$${k}`];
    }
  }
};
var _default = () => {
  // data-wp-context
  (0, _hooks2.directive)('context', ({
    directives: {
      context: {
        default: newContext
      }
    },
    props: {
      children
    },
    context: inheritedContext
  }) => {
    const {
      Provider
    } = inheritedContext;
    const inheritedValue = (0, _hooks.useContext)(inheritedContext);
    const currentValue = (0, _hooks.useRef)((0, _deepsignal.deepSignal)({}));
    currentValue.current = (0, _hooks.useMemo)(() => {
      const newValue = (0, _deepsignal.deepSignal)(newContext);
      mergeDeepSignals(newValue, inheritedValue);
      mergeDeepSignals(currentValue.current, newValue, true);
      return currentValue.current;
    }, [newContext, inheritedValue]);
    return (0, _element.createElement)(Provider, {
      value: currentValue.current
    }, children);
  }, {
    priority: 5
  });

  // data-wp-body
  (0, _hooks2.directive)('body', ({
    props: {
      children
    }
  }) => {
    return (0, _portals.createPortal)(children, document.body);
  });

  // data-wp-effect--[name]
  (0, _hooks2.directive)('effect', ({
    directives: {
      effect
    },
    context,
    evaluate
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    Object.values(effect).forEach(path => {
      (0, _utils.useSignalEffect)(() => {
        return evaluate(path, {
          context: contextValue
        });
      });
    });
  });

  // data-wp-init--[name]
  (0, _hooks2.directive)('init', ({
    directives: {
      init
    },
    context,
    evaluate
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    Object.values(init).forEach(path => {
      (0, _hooks.useEffect)(() => {
        return evaluate(path, {
          context: contextValue
        });
      }, []);
    });
  });

  // data-wp-on--[event]
  (0, _hooks2.directive)('on', ({
    directives: {
      on
    },
    element,
    evaluate,
    context
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    Object.entries(on).forEach(([name, path]) => {
      element.props[`on${name}`] = event => {
        evaluate(path, {
          event,
          context: contextValue
        });
      };
    });
  });

  // data-wp-class--[classname]
  (0, _hooks2.directive)('class', ({
    directives: {
      class: className
    },
    element,
    evaluate,
    context
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    Object.keys(className).filter(n => n !== 'default').forEach(name => {
      const result = evaluate(className[name], {
        className: name,
        context: contextValue
      });
      const currentClass = element.props.class || '';
      const classFinder = new RegExp(`(^|\\s)${name}(\\s|$)`, 'g');
      if (!result) element.props.class = currentClass.replace(classFinder, ' ').trim();else if (!classFinder.test(currentClass)) element.props.class = currentClass ? `${currentClass} ${name}` : name;
      (0, _hooks.useEffect)(() => {
        // This seems necessary because Preact doesn't change the class
        // names on the hydration, so we have to do it manually. It doesn't
        // need deps because it only needs to do it the first time.
        if (!result) {
          element.ref.current.classList.remove(name);
        } else {
          element.ref.current.classList.add(name);
        }
      }, []);
    });
  });
  const newRule = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g;
  const ruleClean = /\/\*[^]*?\*\/|  +/g;
  const ruleNewline = /\n+/g;
  const empty = ' ';

  /**
   * Convert a css style string into a object.
   *
   * Made by Cristian Bote (@cristianbote) for Goober.
   * https://unpkg.com/browse/goober@2.1.13/src/core/astish.js
   *
   * @param {string} val CSS string.
   * @return {Object} CSS object.
   */
  const cssStringToObject = val => {
    const tree = [{}];
    let block, left;
    while (block = newRule.exec(val.replace(ruleClean, ''))) {
      if (block[4]) {
        tree.shift();
      } else if (block[3]) {
        left = block[3].replace(ruleNewline, empty).trim();
        tree.unshift(tree[0][left] = tree[0][left] || {});
      } else {
        tree[0][block[1]] = block[2].replace(ruleNewline, empty).trim();
      }
    }
    return tree[0];
  };

  // data-wp-style--[style-key]
  (0, _hooks2.directive)('style', ({
    directives: {
      style
    },
    element,
    evaluate,
    context
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    Object.keys(style).filter(n => n !== 'default').forEach(key => {
      const result = evaluate(style[key], {
        key,
        context: contextValue
      });
      element.props.style = element.props.style || {};
      if (typeof element.props.style === 'string') element.props.style = cssStringToObject(element.props.style);
      if (!result) delete element.props.style[key];else element.props.style[key] = result;
      (0, _hooks.useEffect)(() => {
        // This seems necessary because Preact doesn't change the styles on
        // the hydration, so we have to do it manually. It doesn't need deps
        // because it only needs to do it the first time.
        if (!result) {
          element.ref.current.style.removeProperty(key);
        } else {
          element.ref.current.style[key] = result;
        }
      }, []);
    });
  });

  // data-wp-bind--[attribute]
  (0, _hooks2.directive)('bind', ({
    directives: {
      bind
    },
    element,
    context,
    evaluate
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    Object.entries(bind).filter(n => n !== 'default').forEach(([attribute, path]) => {
      const result = evaluate(path, {
        context: contextValue
      });
      element.props[attribute] = result;

      // This seems necessary because Preact doesn't change the attributes
      // on the hydration, so we have to do it manually. It doesn't need
      // deps because it only needs to do it the first time.
      (0, _hooks.useEffect)(() => {
        const el = element.ref.current;

        // We set the value directly to the corresponding
        // HTMLElement instance property excluding the following
        // special cases.
        // We follow Preact's logic: https://github.com/preactjs/preact/blob/ea49f7a0f9d1ff2c98c0bdd66aa0cbc583055246/src/diff/props.js#L110-L129
        if (attribute !== 'width' && attribute !== 'height' && attribute !== 'href' && attribute !== 'list' && attribute !== 'form' &&
        // Default value in browsers is `-1` and an empty string is
        // cast to `0` instead
        attribute !== 'tabIndex' && attribute !== 'download' && attribute !== 'rowSpan' && attribute !== 'colSpan' && attribute in el) {
          try {
            el[attribute] = result === null || result === undefined ? '' : result;
            return;
          } catch (err) {}
        }
        // aria- and data- attributes have no boolean representation.
        // A `false` value is different from the attribute not being
        // present, so we can't remove it.
        // We follow Preact's logic: https://github.com/preactjs/preact/blob/ea49f7a0f9d1ff2c98c0bdd66aa0cbc583055246/src/diff/props.js#L131C24-L136
        if (result !== null && result !== undefined && (result !== false || attribute[4] === '-')) {
          el.setAttribute(attribute, result);
        } else {
          el.removeAttribute(attribute);
        }
      }, []);
    });
  });

  // data-wp-ignore
  (0, _hooks2.directive)('ignore', ({
    element: {
      type: Type,
      props: {
        innerHTML,
        ...rest
      }
    }
  }) => {
    // Preserve the initial inner HTML.
    const cached = (0, _hooks.useMemo)(() => innerHTML, []);
    return (0, _element.createElement)(Type, {
      dangerouslySetInnerHTML: {
        __html: cached
      },
      ...rest
    });
  });

  // data-wp-text
  (0, _hooks2.directive)('text', ({
    directives: {
      text: {
        default: text
      }
    },
    element,
    evaluate,
    context
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    element.props.children = evaluate(text, {
      context: contextValue
    });
  });

  // data-wp-slot
  (0, _hooks2.directive)('slot', ({
    directives: {
      slot: {
        default: slot
      }
    },
    props: {
      children
    },
    element
  }) => {
    const name = typeof slot === 'string' ? slot : slot.name;
    const position = slot.position || 'children';
    if (position === 'before') {
      return (0, _element.createElement)(_element.Fragment, null, (0, _element.createElement)(_slots.Slot, {
        name: name
      }), children);
    }
    if (position === 'after') {
      return (0, _element.createElement)(_element.Fragment, null, children, (0, _element.createElement)(_slots.Slot, {
        name: name
      }));
    }
    if (position === 'replace') {
      return (0, _element.createElement)(_slots.Slot, {
        name: name
      }, children);
    }
    if (position === 'children') {
      element.props.children = (0, _element.createElement)(_slots.Slot, {
        name: name
      }, element.props.children);
    }
  }, {
    priority: 4
  });

  // data-wp-fill
  (0, _hooks2.directive)('fill', ({
    directives: {
      fill: {
        default: fill
      }
    },
    props: {
      children
    },
    evaluate,
    context
  }) => {
    const contextValue = (0, _hooks.useContext)(context);
    const slot = evaluate(fill, {
      context: contextValue
    });
    return (0, _element.createElement)(_slots.Fill, {
      slot: slot
    }, children);
  }, {
    priority: 4
  });

  // data-wp-slot-provider
  (0, _hooks2.directive)('slot-provider', ({
    props: {
      children
    }
  }) => (0, _element.createElement)(_slots.SlotProvider, null, children), {
    priority: 4
  });
};
exports.default = _default;
//# sourceMappingURL=directives.js.map