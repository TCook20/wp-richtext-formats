"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _element = require("@wordpress/element");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _blockEditor = require("@wordpress/block-editor");
var _coreData = require("@wordpress/core-data");
/**
 * WordPress dependencies
 */

const PatternEdit = ({
  attributes,
  clientId
}) => {
  const selectedPattern = (0, _data.useSelect)(select => select(_blockEditor.store).__experimentalGetParsedPattern(attributes.slug), [attributes.slug]);
  const currentThemeStylesheet = (0, _data.useSelect)(select => select(_coreData.store).getCurrentTheme().stylesheet);
  const {
    replaceBlocks,
    __unstableMarkNextChangeAsNotPersistent
  } = (0, _data.useDispatch)(_blockEditor.store);
  const {
    setBlockEditingMode
  } = (0, _data.useDispatch)(_blockEditor.store);
  const {
    getBlockRootClientId,
    getBlockEditingMode
  } = (0, _data.useSelect)(_blockEditor.store);
  function injectThemeAttributeInBlockTemplateContent(block) {
    if (block.innerBlocks.find(innerBlock => innerBlock.name === 'core/template-part')) {
      block.innerBlocks = block.innerBlocks.map(innerBlock => {
        if (innerBlock.name === 'core/template-part' && innerBlock.attributes.theme === undefined) {
          innerBlock.attributes.theme = currentThemeStylesheet;
        }
        return innerBlock;
      });
    }
    if (block.name === 'core/template-part' && block.attributes.theme === undefined) {
      block.attributes.theme = currentThemeStylesheet;
    }
    return block;
  }

  // Run this effect when the component loads.
  // This adds the Pattern's contents to the post.
  // This change won't be saved.
  // It will continue to pull from the pattern file unless changes are made to its respective template part.
  (0, _element.useEffect)(() => {
    if (selectedPattern?.blocks) {
      // We batch updates to block list settings to avoid triggering cascading renders
      // for each container block included in a tree and optimize initial render.
      // Since the above uses microtasks, we need to use a microtask here as well,
      // because nested pattern blocks cannot be inserted if the parent block supports
      // inner blocks but doesn't have blockSettings in the state.
      window.queueMicrotask(() => {
        const rootClientId = getBlockRootClientId(clientId);
        // Clone blocks from the pattern before insertion to ensure they receive
        // distinct client ids. See https://github.com/WordPress/gutenberg/issues/50628.
        const clonedBlocks = selectedPattern.blocks.map(block => (0, _blocks.cloneBlock)(injectThemeAttributeInBlockTemplateContent(block)));
        const rootEditingMode = getBlockEditingMode(rootClientId);
        // Temporarily set the root block to default mode to allow replacing the pattern.
        // This could happen when the page is disabling edits of non-content blocks.
        __unstableMarkNextChangeAsNotPersistent();
        setBlockEditingMode(rootClientId, 'default');
        __unstableMarkNextChangeAsNotPersistent();
        replaceBlocks(clientId, clonedBlocks);
        // Restore the root block's original mode.
        __unstableMarkNextChangeAsNotPersistent();
        setBlockEditingMode(rootClientId, rootEditingMode);
      });
    }
  }, [clientId, selectedPattern?.blocks, __unstableMarkNextChangeAsNotPersistent, replaceBlocks, getBlockEditingMode, setBlockEditingMode, getBlockRootClientId]);
  const props = (0, _blockEditor.useBlockProps)();
  return (0, _element.createElement)("div", {
    ...props
  });
};
var _default = PatternEdit;
exports.default = _default;
//# sourceMappingURL=edit.js.map