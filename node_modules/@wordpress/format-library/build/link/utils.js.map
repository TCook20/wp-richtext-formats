{"version":3,"names":["_url","require","isValidHref","href","trimmedHref","trim","test","protocol","getProtocol","isValidProtocol","startsWith","authority","getAuthority","isValidAuthority","path","getPath","isValidPath","queryString","getQueryString","isValidQueryString","fragment","getFragment","isValidFragment","createLinkFormat","url","type","id","opensInNewWindow","format","attributes","target","rel","getFormatBoundary","value","startIndex","start","endIndex","end","EMPTY_BOUNDARIES","formats","targetFormat","initialIndex","length","newFormats","slice","formatAtStart","find","formatAtEnd","formatAtEndMinusOne","index","indexOf","walkingArgs","walkToStart","walkToEnd","walkToBoundary","targetFormatRef","formatIndex","direction","directions","forwards","backwards","directionIncrement","inverseDirectionIncrement","partialRight","fn","partialArgs","args"],"sources":["@wordpress/format-library/src/link/utils.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport {\n\tgetProtocol,\n\tisValidProtocol,\n\tgetAuthority,\n\tisValidAuthority,\n\tgetPath,\n\tisValidPath,\n\tgetQueryString,\n\tisValidQueryString,\n\tgetFragment,\n\tisValidFragment,\n} from '@wordpress/url';\n\n/**\n * Check for issues with the provided href.\n *\n * @param {string} href The href.\n *\n * @return {boolean} Is the href invalid?\n */\nexport function isValidHref( href ) {\n\tif ( ! href ) {\n\t\treturn false;\n\t}\n\n\tconst trimmedHref = href.trim();\n\n\tif ( ! trimmedHref ) {\n\t\treturn false;\n\t}\n\n\t// Does the href start with something that looks like a URL protocol?\n\tif ( /^\\S+:/.test( trimmedHref ) ) {\n\t\tconst protocol = getProtocol( trimmedHref );\n\t\tif ( ! isValidProtocol( protocol ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add some extra checks for http(s) URIs, since these are the most common use-case.\n\t\t// This ensures URIs with an http protocol have exactly two forward slashes following the protocol.\n\t\tif (\n\t\t\tprotocol.startsWith( 'http' ) &&\n\t\t\t! /^https?:\\/\\/[^\\/\\s]/i.test( trimmedHref )\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst authority = getAuthority( trimmedHref );\n\t\tif ( ! isValidAuthority( authority ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst path = getPath( trimmedHref );\n\t\tif ( path && ! isValidPath( path ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst queryString = getQueryString( trimmedHref );\n\t\tif ( queryString && ! isValidQueryString( queryString ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst fragment = getFragment( trimmedHref );\n\t\tif ( fragment && ! isValidFragment( fragment ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// Validate anchor links.\n\tif ( trimmedHref.startsWith( '#' ) && ! isValidFragment( trimmedHref ) ) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/**\n * Generates the format object that will be applied to the link text.\n *\n * @param {Object}  options\n * @param {string}  options.url              The href of the link.\n * @param {string}  options.type             The type of the link.\n * @param {string}  options.id               The ID of the link.\n * @param {boolean} options.opensInNewWindow Whether this link will open in a new window.\n *\n * @return {Object} The final format object.\n */\nexport function createLinkFormat( { url, type, id, opensInNewWindow } ) {\n\tconst format = {\n\t\ttype: 'core/link',\n\t\tattributes: {\n\t\t\turl,\n\t\t},\n\t};\n\n\tif ( type ) format.attributes.type = type;\n\tif ( id ) format.attributes.id = id;\n\n\tif ( opensInNewWindow ) {\n\t\tformat.attributes.target = '_blank';\n\t\tformat.attributes.rel = 'noreferrer noopener';\n\t}\n\n\treturn format;\n}\n\n/* eslint-disable jsdoc/no-undefined-types */\n/**\n * Get the start and end boundaries of a given format from a rich text value.\n *\n *\n * @param {RichTextValue} value      the rich text value to interrogate.\n * @param {string}        format     the identifier for the target format (e.g. `core/link`, `core/bold`).\n * @param {number?}       startIndex optional startIndex to seek from.\n * @param {number?}       endIndex   optional endIndex to seek from.\n * @return {Object}\tobject containing start and end values for the given format.\n */\n/* eslint-enable jsdoc/no-undefined-types */\nexport function getFormatBoundary(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst EMPTY_BOUNDARIES = {\n\t\tstart: null,\n\t\tend: null,\n\t};\n\n\tconst { formats } = value;\n\tlet targetFormat;\n\tlet initialIndex;\n\n\tif ( ! formats?.length ) {\n\t\treturn EMPTY_BOUNDARIES;\n\t}\n\n\t// Clone formats to avoid modifying source formats.\n\tconst newFormats = formats.slice();\n\n\tconst formatAtStart = newFormats[ startIndex ]?.find(\n\t\t( { type } ) => type === format.type\n\t);\n\n\tconst formatAtEnd = newFormats[ endIndex ]?.find(\n\t\t( { type } ) => type === format.type\n\t);\n\n\tconst formatAtEndMinusOne = newFormats[ endIndex - 1 ]?.find(\n\t\t( { type } ) => type === format.type\n\t);\n\n\tif ( !! formatAtStart ) {\n\t\t// Set values to conform to \"start\"\n\t\ttargetFormat = formatAtStart;\n\t\tinitialIndex = startIndex;\n\t} else if ( !! formatAtEnd ) {\n\t\t// Set values to conform to \"end\"\n\t\ttargetFormat = formatAtEnd;\n\t\tinitialIndex = endIndex;\n\t} else if ( !! formatAtEndMinusOne ) {\n\t\t// This is an edge case which will occur if you create a format, then place\n\t\t// the caret just before the format and hit the back ARROW key. The resulting\n\t\t// value object will have start and end +1 beyond the edge of the format boundary.\n\t\ttargetFormat = formatAtEndMinusOne;\n\t\tinitialIndex = endIndex - 1;\n\t} else {\n\t\treturn EMPTY_BOUNDARIES;\n\t}\n\n\tconst index = newFormats[ initialIndex ].indexOf( targetFormat );\n\n\tconst walkingArgs = [ newFormats, initialIndex, targetFormat, index ];\n\n\t// Walk the startIndex \"backwards\" to the leading \"edge\" of the matching format.\n\tstartIndex = walkToStart( ...walkingArgs );\n\n\t// Walk the endIndex \"forwards\" until the trailing \"edge\" of the matching format.\n\tendIndex = walkToEnd( ...walkingArgs );\n\n\t// Safe guard: start index cannot be less than 0.\n\tstartIndex = startIndex < 0 ? 0 : startIndex;\n\n\t// // Return the indicies of the \"edges\" as the boundaries.\n\treturn {\n\t\tstart: startIndex,\n\t\tend: endIndex,\n\t};\n}\n\n/**\n * Walks forwards/backwards towards the boundary of a given format within an\n * array of format objects. Returns the index of the boundary.\n *\n * @param {Array}  formats         the formats to search for the given format type.\n * @param {number} initialIndex    the starting index from which to walk.\n * @param {Object} targetFormatRef a reference to the format type object being sought.\n * @param {number} formatIndex     the index at which we expect the target format object to be.\n * @param {string} direction       either 'forwards' or 'backwards' to indicate the direction.\n * @return {number} the index of the boundary of the given format.\n */\nfunction walkToBoundary(\n\tformats,\n\tinitialIndex,\n\ttargetFormatRef,\n\tformatIndex,\n\tdirection\n) {\n\tlet index = initialIndex;\n\n\tconst directions = {\n\t\tforwards: 1,\n\t\tbackwards: -1,\n\t};\n\n\tconst directionIncrement = directions[ direction ] || 1; // invalid direction arg default to forwards\n\tconst inverseDirectionIncrement = directionIncrement * -1;\n\n\twhile (\n\t\tformats[ index ] &&\n\t\tformats[ index ][ formatIndex ] === targetFormatRef\n\t) {\n\t\t// Increment/decrement in the direction of operation.\n\t\tindex = index + directionIncrement;\n\t}\n\n\t// Restore by one in inverse direction of operation\n\t// to avoid out of bounds.\n\tindex = index + inverseDirectionIncrement;\n\n\treturn index;\n}\n\nconst partialRight =\n\t( fn, ...partialArgs ) =>\n\t( ...args ) =>\n\t\tfn( ...args, ...partialArgs );\n\nconst walkToStart = partialRight( walkToBoundary, 'backwards' );\n\nconst walkToEnd = partialRight( walkToBoundary, 'forwards' );\n"],"mappings":";;;;;;;;AAGA,IAAAA,IAAA,GAAAC,OAAA;AAHA;AACA;AACA;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,WAAWA,CAAEC,IAAI,EAAG;EACnC,IAAK,CAAEA,IAAI,EAAG;IACb,OAAO,KAAK;EACb;EAEA,MAAMC,WAAW,GAAGD,IAAI,CAACE,IAAI,CAAC,CAAC;EAE/B,IAAK,CAAED,WAAW,EAAG;IACpB,OAAO,KAAK;EACb;;EAEA;EACA,IAAK,OAAO,CAACE,IAAI,CAAEF,WAAY,CAAC,EAAG;IAClC,MAAMG,QAAQ,GAAG,IAAAC,gBAAW,EAAEJ,WAAY,CAAC;IAC3C,IAAK,CAAE,IAAAK,oBAAe,EAAEF,QAAS,CAAC,EAAG;MACpC,OAAO,KAAK;IACb;;IAEA;IACA;IACA,IACCA,QAAQ,CAACG,UAAU,CAAE,MAAO,CAAC,IAC7B,CAAE,sBAAsB,CAACJ,IAAI,CAAEF,WAAY,CAAC,EAC3C;MACD,OAAO,KAAK;IACb;IAEA,MAAMO,SAAS,GAAG,IAAAC,iBAAY,EAAER,WAAY,CAAC;IAC7C,IAAK,CAAE,IAAAS,qBAAgB,EAAEF,SAAU,CAAC,EAAG;MACtC,OAAO,KAAK;IACb;IAEA,MAAMG,IAAI,GAAG,IAAAC,YAAO,EAAEX,WAAY,CAAC;IACnC,IAAKU,IAAI,IAAI,CAAE,IAAAE,gBAAW,EAAEF,IAAK,CAAC,EAAG;MACpC,OAAO,KAAK;IACb;IAEA,MAAMG,WAAW,GAAG,IAAAC,mBAAc,EAAEd,WAAY,CAAC;IACjD,IAAKa,WAAW,IAAI,CAAE,IAAAE,uBAAkB,EAAEF,WAAY,CAAC,EAAG;MACzD,OAAO,KAAK;IACb;IAEA,MAAMG,QAAQ,GAAG,IAAAC,gBAAW,EAAEjB,WAAY,CAAC;IAC3C,IAAKgB,QAAQ,IAAI,CAAE,IAAAE,oBAAe,EAAEF,QAAS,CAAC,EAAG;MAChD,OAAO,KAAK;IACb;EACD;;EAEA;EACA,IAAKhB,WAAW,CAACM,UAAU,CAAE,GAAI,CAAC,IAAI,CAAE,IAAAY,oBAAe,EAAElB,WAAY,CAAC,EAAG;IACxE,OAAO,KAAK;EACb;EAEA,OAAO,IAAI;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASmB,gBAAgBA,CAAE;EAAEC,GAAG;EAAEC,IAAI;EAAEC,EAAE;EAAEC;AAAiB,CAAC,EAAG;EACvE,MAAMC,MAAM,GAAG;IACdH,IAAI,EAAE,WAAW;IACjBI,UAAU,EAAE;MACXL;IACD;EACD,CAAC;EAED,IAAKC,IAAI,EAAGG,MAAM,CAACC,UAAU,CAACJ,IAAI,GAAGA,IAAI;EACzC,IAAKC,EAAE,EAAGE,MAAM,CAACC,UAAU,CAACH,EAAE,GAAGA,EAAE;EAEnC,IAAKC,gBAAgB,EAAG;IACvBC,MAAM,CAACC,UAAU,CAACC,MAAM,GAAG,QAAQ;IACnCF,MAAM,CAACC,UAAU,CAACE,GAAG,GAAG,qBAAqB;EAC9C;EAEA,OAAOH,MAAM;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,iBAAiBA,CAChCC,KAAK,EACLL,MAAM,EACNM,UAAU,GAAGD,KAAK,CAACE,KAAK,EACxBC,QAAQ,GAAGH,KAAK,CAACI,GAAG,EACnB;EACD,MAAMC,gBAAgB,GAAG;IACxBH,KAAK,EAAE,IAAI;IACXE,GAAG,EAAE;EACN,CAAC;EAED,MAAM;IAAEE;EAAQ,CAAC,GAAGN,KAAK;EACzB,IAAIO,YAAY;EAChB,IAAIC,YAAY;EAEhB,IAAK,CAAEF,OAAO,EAAEG,MAAM,EAAG;IACxB,OAAOJ,gBAAgB;EACxB;;EAEA;EACA,MAAMK,UAAU,GAAGJ,OAAO,CAACK,KAAK,CAAC,CAAC;EAElC,MAAMC,aAAa,GAAGF,UAAU,CAAET,UAAU,CAAE,EAAEY,IAAI,CACnD,CAAE;IAAErB;EAAK,CAAC,KAAMA,IAAI,KAAKG,MAAM,CAACH,IACjC,CAAC;EAED,MAAMsB,WAAW,GAAGJ,UAAU,CAAEP,QAAQ,CAAE,EAAEU,IAAI,CAC/C,CAAE;IAAErB;EAAK,CAAC,KAAMA,IAAI,KAAKG,MAAM,CAACH,IACjC,CAAC;EAED,MAAMuB,mBAAmB,GAAGL,UAAU,CAAEP,QAAQ,GAAG,CAAC,CAAE,EAAEU,IAAI,CAC3D,CAAE;IAAErB;EAAK,CAAC,KAAMA,IAAI,KAAKG,MAAM,CAACH,IACjC,CAAC;EAED,IAAK,CAAC,CAAEoB,aAAa,EAAG;IACvB;IACAL,YAAY,GAAGK,aAAa;IAC5BJ,YAAY,GAAGP,UAAU;EAC1B,CAAC,MAAM,IAAK,CAAC,CAAEa,WAAW,EAAG;IAC5B;IACAP,YAAY,GAAGO,WAAW;IAC1BN,YAAY,GAAGL,QAAQ;EACxB,CAAC,MAAM,IAAK,CAAC,CAAEY,mBAAmB,EAAG;IACpC;IACA;IACA;IACAR,YAAY,GAAGQ,mBAAmB;IAClCP,YAAY,GAAGL,QAAQ,GAAG,CAAC;EAC5B,CAAC,MAAM;IACN,OAAOE,gBAAgB;EACxB;EAEA,MAAMW,KAAK,GAAGN,UAAU,CAAEF,YAAY,CAAE,CAACS,OAAO,CAAEV,YAAa,CAAC;EAEhE,MAAMW,WAAW,GAAG,CAAER,UAAU,EAAEF,YAAY,EAAED,YAAY,EAAES,KAAK,CAAE;;EAErE;EACAf,UAAU,GAAGkB,WAAW,CAAE,GAAGD,WAAY,CAAC;;EAE1C;EACAf,QAAQ,GAAGiB,SAAS,CAAE,GAAGF,WAAY,CAAC;;EAEtC;EACAjB,UAAU,GAAGA,UAAU,GAAG,CAAC,GAAG,CAAC,GAAGA,UAAU;;EAE5C;EACA,OAAO;IACNC,KAAK,EAAED,UAAU;IACjBG,GAAG,EAAED;EACN,CAAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,cAAcA,CACtBf,OAAO,EACPE,YAAY,EACZc,eAAe,EACfC,WAAW,EACXC,SAAS,EACR;EACD,IAAIR,KAAK,GAAGR,YAAY;EAExB,MAAMiB,UAAU,GAAG;IAClBC,QAAQ,EAAE,CAAC;IACXC,SAAS,EAAE,CAAC;EACb,CAAC;EAED,MAAMC,kBAAkB,GAAGH,UAAU,CAAED,SAAS,CAAE,IAAI,CAAC,CAAC,CAAC;EACzD,MAAMK,yBAAyB,GAAGD,kBAAkB,GAAG,CAAC,CAAC;EAEzD,OACCtB,OAAO,CAAEU,KAAK,CAAE,IAChBV,OAAO,CAAEU,KAAK,CAAE,CAAEO,WAAW,CAAE,KAAKD,eAAe,EAClD;IACD;IACAN,KAAK,GAAGA,KAAK,GAAGY,kBAAkB;EACnC;;EAEA;EACA;EACAZ,KAAK,GAAGA,KAAK,GAAGa,yBAAyB;EAEzC,OAAOb,KAAK;AACb;AAEA,MAAMc,YAAY,GACjBA,CAAEC,EAAE,EAAE,GAAGC,WAAW,KACpB,CAAE,GAAGC,IAAI,KACRF,EAAE,CAAE,GAAGE,IAAI,EAAE,GAAGD,WAAY,CAAC;AAE/B,MAAMb,WAAW,GAAGW,YAAY,CAAET,cAAc,EAAE,WAAY,CAAC;AAE/D,MAAMD,SAAS,GAAGU,YAAY,CAAET,cAAc,EAAE,UAAW,CAAC"}